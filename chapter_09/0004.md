# 享元模式

## 1. 使用场景
当很多线程需要重用数量有限的同一类对象时。

例如：一个线上商城应用，QPS达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。

这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。

## 2. 实现举例

{%ace edit=false, lang='java', theme='monokai'%}
class Pool {
  public Pool(int poolSize) {
    this.poolSize = poolSize;
  }

  private int poolSize;
  private Connection[] conns;
  private AtomicBoolean[] locks;

  public void init() {
    conns = new Connection[poolSize];
    locks = new AtomicBoolean[poolSize];
    for (int i = 0; i < poolSize; i++) {
      conns[i] = new SomeConnection("conn" + (i + 1));
      locks[i] = new AtomicBoolean(false);
    }
  }

  public Connection borrow() {
    while (true) {
      for (int i = 0; i < poolSize; i++) {
        if (locks[i].get() == false) {
          locks[i].compareAndSet(false, true);
          return conns[i];
        }
      }
      synchronized (this) {
        try {
          this.wait();
        } catch (InterruptedException e) {
        }
      }
    }
  }

  public void free(Connection conn) {
    for (int i = 0; i < poolSize; i++) {
      if (conns[i] == conn) {
        locks[i].compareAndSet(true, false);
        synchronized (this) {
          this.notify();
        }
      }
    }
  }
}

class SomeConnection implements Connection {
  // 实现略
}
{%endace%}


