# 原型模式

## 1. 使用场景
当一个对象的创建过程非常复杂，而我们只需要复制一个已存在对象的状态时。

## 2. 实现举例
希望根据一个已有的Student对象，复制（克隆）另一个新的Student对象：

### 深拷贝

{%ace edit=false, lang='java', theme='monokai'%}
class Student implements Serializable {
  private static final long serialVersionUID = 1L;
  int id;
  String name;
  Date birthday;

  public Student(int id, String name, Date birthday) {
    super();
    this.id = id;
    this.name = name;
    this.birthday = birthday;
  }

  @Override
  public String toString() {
    return "Student [id=" + id + ", name=" + name + ", birthday=" + birthday + "]";
  }

  public Student clone() {
    try {
      ByteArrayOutputStream os = new ByteArrayOutputStream();
      ObjectOutputStream oos = new ObjectOutputStream(os);
      oos.writeObject(this);
      ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
      ObjectInputStream ois = new ObjectInputStream(is);
      return (Student) ois.readObject();
    } catch (ClassNotFoundException | IOException e) {
      throw new RuntimeException(e);
    }
  }

}
{%endace%}

使用：

{%ace edit=false, lang='java', theme='monokai'%}
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
Student s1 = new Student(1, "张三", sdf.parse("1995-05-21"));

Student s2 = s1.clone();
System.out.println(s1);
System.out.println(s2);
System.out.println(s2 == s1);
System.out.println(s2.birthday == s1.birthday);
{%endace%}

输出：
```
Student [id=1, name=张三, birthday=Sun May 21 00:00:00 CST 1995]
Student [id=1, name=张三, birthday=Sun May 21 00:00:00 CST 1995]
false
false
```
> ### 要点
* 利用了对象流和数组流进行了byte级别的复制，效率较高
* 因为是byte级别的复制，因此像Date这样的可变对象也会复制成功
* 需要实现Serializable接口，类中的各个field 也需要实现Serializable

