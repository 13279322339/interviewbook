# java.util.concurrent包中借助CAS实现锁，它与synchronous 的区别是什么？

# 答案

CAS就像是乐观锁在java中的实现，多个线程要对一个临界资源执行+1操作：
while(true) { // 需要不断尝试
int 旧值 = ...; // 比如说第一轮拿到了1
int 结果 = 旧值 + 1; // 对我当前线程来说，结果是2 
/* 比较临界资源的值还是不是1，这时候如果别的线程把它改了，那么compareAndSet	   返回false，进入下一轮比较（否则我的修会覆盖别人的修改）；如果别的线程	    
   还没有修改它，这时候就用当前线程的结果修改掉临界资源，并返回true */
if(compareAndSet(临界资源，结果)) { 
    // 成功，退出循环
}
}
这里compareAndSet是这里的关键，现代的CPU指令集中都支持CAS相关指令，在java中已经做好了底层封装。java.util.concurrent包中的很多类都是利用了compareAndSet方法解决并发冲突问题

